using System.Diagnostics;
using System.Globalization;
using System.Reflection;
using System.Text;

class GenerateCultureInfoCpp {
  static void Main() {
    if (IsUsingNls()) {
      Trace.WriteLine("ERROR: The current .NET runtime is not using ICU/CLDR for globalization.");
      Environment.Exit(1);
    }
    
    var xtdSourcesPath = Path.Combine(new[] { "..", "..", "..", "..", "..", "src", "xtd.core", "src", "xtd" });
    Console.WriteLine("Generation started");
    Console.Write("  * Generate Cultures...  ");
    Console.WriteLine(GenerateCultures(Path.Combine(new[] { xtdSourcesPath, "globalization", "culture_info_cultures.cpp" })) ? "[SUCCEED]" : "[FAILED ]");
    Console.Write("  * Generate DateTimeFormats...  ");
    Console.WriteLine(GenerateDateTimeFormats(Path.Combine(new[] { xtdSourcesPath, "globalization", "date_time_format_info_formats.cpp" })) ? "[SUCCEED]" : "[FAILED ]");
    Console.Write("  * Generate TimeZones... ");
    Console.WriteLine(GenerateTimeZones(Path.Combine(new[] { xtdSourcesPath, "time_zone_info_system_time_zones.cpp" })) ? "[SUCCEED]" : "[FAILED ]");
    Console.WriteLine("Generation ended");
    Environment.Exit(Environment.ExitCode);
  }

  static bool GenerateCultures(string file_path) {
    try {
      var sb = new StringBuilder();
      sb.AppendLine("// This code was generated by tools/GenerateCultureInfoCpp.");
      sb.AppendLine("//");
      sb.AppendLine("// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.");
      sb.AppendLine();
      sb.AppendLine("#include \"../../../include/xtd/globalization/culture_info.hpp\"");
      sb.AppendLine();
      sb.AppendLine("using namespace xtd;");
      sb.AppendLine("using namespace xtd::collections::generic;");
      sb.AppendLine("using namespace xtd::globalization;");
      sb.AppendLine();
      sb.AppendLine("dictionary<string, culture_info> culture_info::cultures_ = dictionary<string, culture_info> {");

      foreach (var cultureInfo in CultureInfo.GetCultures(CultureTypes.AllCultures).OrderBy(culture => culture.Name))
        sb.AppendLine(ToString(cultureInfo, Escape(cultureInfo.Name.ToLower())));
      sb.AppendLine("};");
      File.WriteAllText(file_path, sb.ToString(), Encoding.UTF8);
      return true;
    } catch (Exception e) {
      Trace.WriteLine("ERROR: " + e.Message);
      Environment.ExitCode = 2;
      return false;
    }
  }

  static bool GenerateDateTimeFormats(string file_path) {
    try {
      var sb = new StringBuilder();
      sb.AppendLine("// This code was generated by tools/GenerateCultureInfoCpp.");
      sb.AppendLine("//");
      sb.AppendLine("// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.");
      sb.AppendLine();
      sb.AppendLine("#include \"../../../include/xtd/globalization/date_time_format_info.hpp\"");
      sb.AppendLine("#include \"../../../include/xtd/day_of_week.hpp\"");
      sb.AppendLine();
      sb.AppendLine("using namespace xtd;");
      sb.AppendLine("using namespace xtd::collections::generic;");
      sb.AppendLine("using namespace xtd::globalization;");
      sb.AppendLine();
      sb.AppendLine("dictionary<string, date_time_format_info> date_time_format_info::formats_ = dictionary<string, date_time_format_info> {");

      foreach (var cultureInfo in CultureInfo.GetCultures(CultureTypes.AllCultures).OrderBy(culture => culture.Name))
        sb.AppendLine(ToString(cultureInfo.DateTimeFormat, Escape(cultureInfo.Name.ToLower())));
      sb.AppendLine("};");
      File.WriteAllText(file_path, sb.ToString(), Encoding.UTF8);
      return true;
    } catch (Exception e) {
      Trace.WriteLine("ERROR: " + e.Message);
      Environment.ExitCode = 2;
      return false;
    }
  }

  static bool GenerateTimeZones(string file_path) {
    Trace.WriteLine("ERROR: Not yet implemented.");
      Environment.ExitCode = 3;
    return false;
  }

  static string Escape(string text) => text.Replace("\\", "\\\\").Replace("\"", "\\\"");

  static bool IsUsingNls() {
    var property = typeof(CultureInfo).Assembly.GetType("System.Globalization.GlobalizationMode")?.GetProperty("UseNls", BindingFlags.Static | BindingFlags.NonPublic);
    return property != null && (bool)property.GetValue(null)!;
  }

  static string ToString(CultureInfo cultureInfo, string key) {
    return $"  key_value_pair<string, culture_info>(\"{key}\", {ToString(cultureInfo)}),";
  }

  static string ToString(CultureInfo cultureInfo) {
    var cultureType = ToString(cultureInfo.CultureTypes & CultureTypes.AllCultures);
    var displayName = ToString(cultureInfo.DisplayName);
    var englishName = ToString(cultureInfo.EnglishName);
    var keyboardLayoutId = cultureInfo.KeyboardLayoutId;
    var lcid = cultureInfo.LCID;
    var name = ToString(cultureInfo.Name);
    var nativeName = ToString(cultureInfo.NativeName);
    var parentName = ToString(cultureInfo.Parent.Name);
    var threeLetterISOLanguageName = ToString(cultureInfo.ThreeLetterISOLanguageName);
    var threeLetterWindowsLanguageName = ToString(cultureInfo.ThreeLetterWindowsLanguageName);
    var twoLetterISOLanguageName = ToString(cultureInfo.TwoLetterISOLanguageName);
    return $"culture_info({cultureType}, {displayName}, {englishName}, {keyboardLayoutId}, {lcid}, {name}, {nativeName}, {parentName}, {threeLetterISOLanguageName}, {threeLetterWindowsLanguageName}, {twoLetterISOLanguageName})";
  }

  static string ToString(CultureTypes type) {
    var result = string.Empty;
    if (type.HasFlag(CultureTypes.NeutralCultures)) result = "globalization::culture_types::neutral_cultures";
    if (type.HasFlag(CultureTypes.SpecificCultures)) result += (string.IsNullOrEmpty(result) ? "" : "|") + "globalization::culture_types::specific_cultures";
    if (type.HasFlag(CultureTypes.InstalledWin32Cultures)) result += (string.IsNullOrEmpty(result) ? "" : "|") + "globalization::culture_types::installed_win32_cultures";
    if (string.IsNullOrEmpty(result)) result = "globalization::culture_types::none";
    return result;
  }
  
  static string ToString(DateTimeFormatInfo dateTimeFormat, string key) {
    return $"  key_value_pair<string, date_time_format_info>(\"{key}\", {ToString(dateTimeFormat)}),";
  }
  
  static string ToString(DateTimeFormatInfo dateTimeFormat) {
    var abbreviatedDayNames = ToString(dateTimeFormat.AbbreviatedDayNames);
    var abbreviatedMonthGenitiveNames = ToString(dateTimeFormat.AbbreviatedMonthGenitiveNames);
    var abbreviatedMonthNames = ToString(dateTimeFormat.AbbreviatedMonthNames);
    var amDesignator = ToString(dateTimeFormat.AMDesignator);
    var dateSeparator = ToString(dateTimeFormat.DateSeparator);
    var dayNames = ToString(dateTimeFormat.DayNames);
    var firstDayOfWeek = ToString(dateTimeFormat.FirstDayOfWeek);
    var fullDateTimePattern = ToString(dateTimeFormat.FullDateTimePattern);
    var longDatePattern = ToString(dateTimeFormat.LongDatePattern);
    var longTimePattern = ToString(dateTimeFormat.LongTimePattern);
    var monthDayPattern = ToString(dateTimeFormat.MonthDayPattern);
    var monthGenitiveNames = ToString(dateTimeFormat.MonthGenitiveNames);
    var monthNames = ToString(dateTimeFormat.MonthNames);
    var nativeCalendarName = ToString(dateTimeFormat.NativeCalendarName);
    var pmDesignator = ToString(dateTimeFormat.PMDesignator);
    var rfc1123Pattern = ToString(dateTimeFormat.RFC1123Pattern);
    var shortatePattern = ToString(dateTimeFormat.ShortDatePattern);
    var shortTimePattern = ToString(dateTimeFormat.ShortTimePattern);
    var shortestDayNames = ToString(dateTimeFormat.ShortestDayNames);
    var sortableDateTimePattern = ToString(dateTimeFormat.SortableDateTimePattern);
    var timeSeparator = ToString(dateTimeFormat.TimeSeparator);
    var universalSortableDateTimePattern = ToString(dateTimeFormat.UniversalSortableDateTimePattern);
    var yearMonthPattern = ToString(dateTimeFormat.YearMonthPattern);
    return $"date_time_format_info({abbreviatedDayNames}, {abbreviatedMonthGenitiveNames}, {abbreviatedMonthNames}, {amDesignator}, {dateSeparator}, {dayNames}, {firstDayOfWeek}, {fullDateTimePattern}, {longDatePattern}, {longTimePattern}, {monthDayPattern}, {monthGenitiveNames}, {monthNames}, {nativeCalendarName}, {pmDesignator}, {rfc1123Pattern}, {shortatePattern}, {shortTimePattern}, {shortestDayNames}, {sortableDateTimePattern}, {timeSeparator}, {universalSortableDateTimePattern}, {yearMonthPattern})";
  }
   
  static string ToString(NumberFormatInfo numberFormat, string key) {
    return $"  key_value_pair<string, number_format_info>(\"{key}\", {ToString(numberFormat)}),";
  }

  static string ToString(NumberFormatInfo numberFormat) {
    var currencyDecimalDigits = ToString(numberFormat.CurrencyDecimalDigits);
    var currencyDecimalSeparator = ToString(numberFormat.CurrencyDecimalSeparator);
    return $"date_time_format_info({currencyDecimalDigits}, {currencyDecimalSeparator})";
  }

  static string ToString(DayOfWeek dayOfWeek) {
    return $"xtd::day_of_week::{dayOfWeek.ToString().ToLower()}";
  }
  
  static string ToString(int value) {
    return $"{value}";
  }
  
  static string ToString(int[] values) {
    return $"array<string> {{{string.Join(", ", values)}}}";
  }
  
  static string ToString(string value) {
    return $"\"{Escape(value)}\"";
  }
  
  static string ToString(string[] values) {
    return $"array<string> {{{string.Join(", ", values.Select(v => ToString(v)))}}}";
  }
}
