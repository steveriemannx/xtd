using System.Diagnostics;
using System.Globalization;
using System.Reflection;
using System.Text;

class GenerateCultureInfoCpp {
  static void Main() {
    if (IsUsingNls()) {
      Trace.WriteLine("ERROR: The current .NET runtime is not using ICU/CLDR for globalization.");
      Environment.Exit(1);
    }
    
    var xtdSourcesPath = Path.Combine(new[] { "..", "..", "..", "..", "..", "src", "xtd.core", "src", "xtd" });
    Console.WriteLine("Generation started");
    Console.Write("  * Generate Cultures...         ");
    Console.WriteLine(GenerateCultures(Path.Combine(new[] {xtdSourcesPath, "globalization", "culture_info_cultures.cpp"})) ? "[SUCCEED]" : "[FAILED ]");
    Console.Write("  * Generate DateTimeFormats...  ");
    Console.WriteLine(GenerateDateTimeFormats(Path.Combine(new[] {xtdSourcesPath, "globalization", "date_time_format_info_formats.cpp"})) ? "[SUCCEED]" : "[FAILED ]");
    Console.Write("  * Generate NumberFormats...    ");
    Console.WriteLine(GenerateNumberFormats(Path.Combine(new[] {xtdSourcesPath, "globalization", "number_format_info_formats.cpp"})) ? "[SUCCEED]" : "[FAILED ]");
    Console.Write("  * Generate TimeZones...        ");
    Console.WriteLine(GenerateTimeZones(Path.Combine(new[] {xtdSourcesPath, "time_zone_info_system_time_zones.cpp"})) ? "[SUCCEED]" : "[FAILED ]");
    Console.WriteLine("Generation ended");
    Environment.Exit(Environment.ExitCode);
  }

  static bool GenerateCultures(string file_path) {
    try {
      var sb = new StringBuilder();
      sb.AppendLine("// This code was generated by tools/GenerateCultureInfoCpp.");
      sb.AppendLine("//");
      sb.AppendLine("// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.");
      sb.AppendLine();
      sb.AppendLine("#include \"../../../include/xtd/globalization/culture_info.hpp\"");
      sb.AppendLine("#include \"../../../include/xtd/call_once.hpp\"");
      sb.AppendLine();
      sb.AppendLine("using namespace xtd;");
      sb.AppendLine("using namespace xtd::collections::generic;");
      sb.AppendLine("using namespace xtd::globalization;");
      sb.AppendLine();
      sb.AppendLine("dictionary<string, culture_info>& culture_info::cultures() {");
      sb.AppendLine("  static auto cultures = dictionary<string, culture_info> {};");
      sb.AppendLine("  call_once_ {");
      foreach (var cultureInfo in CultureInfo.GetCultures(CultureTypes.AllCultures).OrderBy(culture => culture.Name))
        sb.AppendLine(ToString(cultureInfo, ToString(cultureInfo.Name.ToLower())));
      sb.AppendLine("  };");
      sb.AppendLine("  return cultures;");
      sb.AppendLine("}");
      File.WriteAllText(file_path, sb.ToString(), Encoding.UTF8);
      return true;
    } catch (Exception e) {
      Trace.WriteLine("ERROR: " + e.Message);
      Environment.ExitCode = 2;
      return false;
    }
  }

  static bool GenerateDateTimeFormats(string file_path) {
    try {
      var sb = new StringBuilder();
      sb.AppendLine("// This code was generated by tools/GenerateCultureInfoCpp.");
      sb.AppendLine("//");
      sb.AppendLine("// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.");
      sb.AppendLine();
      sb.AppendLine("#include \"../../../include/xtd/globalization/date_time_format_info.hpp\"");
      sb.AppendLine("#include \"../../../include/xtd/day_of_week.hpp\"");
      sb.AppendLine("#include \"../../../include/xtd/call_once.hpp\"");
      sb.AppendLine();
      sb.AppendLine("using namespace xtd;");
      sb.AppendLine("using namespace xtd::collections::generic;");
      sb.AppendLine("using namespace xtd::globalization;");
      sb.AppendLine();
      sb.AppendLine("dictionary<string, date_time_format_info>& date_time_format_info::formats() {");
      sb.AppendLine("  static auto formats = dictionary<string, date_time_format_info> {};");
      sb.AppendLine("  call_once_ {");
      foreach (var cultureInfo in CultureInfo.GetCultures(CultureTypes.AllCultures).OrderBy(culture => culture.Name))
        sb.AppendLine(ToString(cultureInfo.DateTimeFormat, ToString(cultureInfo.Name.ToLower())));
      sb.AppendLine("  };");
      sb.AppendLine("  return formats;");
      sb.AppendLine("}");
      File.WriteAllText(file_path, sb.ToString(), Encoding.UTF8);
      return true;
    } catch (Exception e) {
      Trace.WriteLine("ERROR: " + e.Message);
      Environment.ExitCode = 3;
      return false;
    }
  }

  static bool GenerateNumberFormats(string file_path) {
    try {
      var sb = new StringBuilder();
      sb.AppendLine("// This code was generated by tools/GenerateCultureInfoCpp.");
      sb.AppendLine("//");
      sb.AppendLine("// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.");
      sb.AppendLine();
      sb.AppendLine("#include \"../../../include/xtd/globalization/number_format_info.hpp\"");
      sb.AppendLine("#include \"../../../include/xtd/call_once.hpp\"");
      sb.AppendLine();
      sb.AppendLine("using namespace xtd;");
      sb.AppendLine("using namespace xtd::collections::generic;");
      sb.AppendLine("using namespace xtd::globalization;");
      sb.AppendLine();
      sb.AppendLine("dictionary<string, number_format_info>& number_format_info::formats() {");
      sb.AppendLine("  static auto formats = dictionary<string, number_format_info> {};");
      sb.AppendLine("  call_once_ {");
      foreach (var cultureInfo in CultureInfo.GetCultures(CultureTypes.AllCultures).OrderBy(culture => culture.Name))
        sb.AppendLine(ToString(cultureInfo.NumberFormat, ToString(cultureInfo.Name.ToLower())));
      sb.AppendLine("  };");
      sb.AppendLine("  return formats;");
      sb.AppendLine("}");
      File.WriteAllText(file_path, sb.ToString(), Encoding.UTF8);
      return true;
    } catch (Exception e) {
      Trace.WriteLine("ERROR: " + e.Message);
      Environment.ExitCode = 3;
      return false;
    }
  }

  static bool GenerateTimeZones(string file_path) {
    Trace.WriteLine("ERROR: Not yet implemented.");
    Environment.ExitCode = 4;
    return false;
  }

  static bool IsUsingNls() {
    var property = typeof(CultureInfo).Assembly.GetType("System.Globalization.GlobalizationMode")?.GetProperty("UseNls", BindingFlags.Static | BindingFlags.NonPublic);
    return property != null && (bool)property.GetValue(null)!;
  }

  static string ToString(CultureInfo cultureInfo, string key) {
    return $"    cultures[{key}] = {ToString(cultureInfo)};";
  }

  static string ToString(CultureInfo cultureInfo) {
    return $"culture_info({ToString(cultureInfo.CultureTypes & CultureTypes.AllCultures)}, {ToString(cultureInfo.DisplayName)}, {ToString(cultureInfo.EnglishName)}, {ToString(cultureInfo.KeyboardLayoutId)}, {ToString(cultureInfo.LCID)}, {ToString(cultureInfo.Name)}, {ToString(cultureInfo.NativeName)}, {ToString(cultureInfo.Parent.Name)}, {ToString(cultureInfo.ThreeLetterISOLanguageName)}, {ToString(cultureInfo.ThreeLetterWindowsLanguageName)}, {ToString(cultureInfo.TwoLetterISOLanguageName)})";
  }

  static string ToString(CultureTypes type) {
    var result = string.Empty;
    if (type.HasFlag(CultureTypes.NeutralCultures)) result = "globalization::culture_types::neutral_cultures";
    if (type.HasFlag(CultureTypes.SpecificCultures)) result += (string.IsNullOrEmpty(result) ? "" : "|") + "globalization::culture_types::specific_cultures";
    if (type.HasFlag(CultureTypes.InstalledWin32Cultures)) result += (string.IsNullOrEmpty(result) ? "" : "|") + "globalization::culture_types::installed_win32_cultures";
    if (string.IsNullOrEmpty(result)) result = "globalization::culture_types::none";
    return result;
  }
  
  static string ToString(DateTimeFormatInfo dateTimeFormat, string key) {
    return $"    formats[{key}] = {ToString(dateTimeFormat)};";
  }
  
  static string ToString(DateTimeFormatInfo dateTimeFormat) {
    return $"date_time_format_info({ToString(dateTimeFormat.AbbreviatedDayNames)}, {ToString(dateTimeFormat.AbbreviatedMonthGenitiveNames)}, {ToString(dateTimeFormat.AbbreviatedMonthNames)}, {ToString(dateTimeFormat.AMDesignator)}, {ToString(dateTimeFormat.DateSeparator)}, {ToString(dateTimeFormat.DayNames)}, {ToString(dateTimeFormat.FirstDayOfWeek)}, {ToString(dateTimeFormat.FullDateTimePattern)}, {ToString(dateTimeFormat.LongDatePattern)}, {ToString(dateTimeFormat.LongTimePattern)}, {ToString(dateTimeFormat.MonthDayPattern)}, {ToString(dateTimeFormat.MonthGenitiveNames)}, {ToString(dateTimeFormat.MonthNames)}, {ToString(dateTimeFormat.NativeCalendarName)}, {ToString(dateTimeFormat.PMDesignator)}, {ToString(dateTimeFormat.RFC1123Pattern)}, {ToString(dateTimeFormat.ShortDatePattern)}, {ToString(dateTimeFormat.ShortTimePattern)}, {ToString(dateTimeFormat.ShortestDayNames)}, {ToString(dateTimeFormat.SortableDateTimePattern)}, {ToString(dateTimeFormat.TimeSeparator)}, {ToString(dateTimeFormat.UniversalSortableDateTimePattern)}, {ToString(dateTimeFormat.YearMonthPattern)})";
  }
   
  static string ToString(NumberFormatInfo numberFormat, string key) {
    return $"    formats[{key}] = {ToString(numberFormat)};";
  }

  static string ToString(NumberFormatInfo numberFormat) {
    return $"number_format_info({ToString(numberFormat.CurrencyDecimalDigits)}, {ToString(numberFormat.CurrencyDecimalSeparator)}, {ToString(numberFormat.CurrencyGroupSizes)}, {ToString(numberFormat.CurrencyNegativePattern)}, {ToString(numberFormat.CurrencyPositivePattern)}, {ToString(numberFormat.CurrencySymbol)})";
  }

  static string ToString(DayOfWeek dayOfWeek) {
    return $"xtd::day_of_week::{dayOfWeek.ToString().ToLower()}";
  }
  
  static string ToString(int value) {
    return $"{value}";
  }
  
  static string ToString(int[] values) {
    return $"array<size> {{{string.Join(", ", values)}}}";
  }
  
  static string ToString(string value) {
    return $"\"{value.Replace("\\", "\\\\").Replace("\"", "\\\"")}\"";
  }
  
  static string ToString(string[] values) {
    return $"array<string> {{{string.Join(", ", values.Select(value => ToString(value)))}}}";
  }
}
