using System.Diagnostics;
using System.Globalization;
using System.Reflection;
using System.Text;

class GenerateCultureInfoCpp {
  static void Main() {
    if (IsUsingNls()) {
      Trace.WriteLine("ERROR: The current .NET runtime is not using ICU/CLDR for globalization.");
      Environment.Exit(1);
    }
    
    var xtdSourcesPath = Path.Combine(new[] { "..", "..", "..", "..", "..", "src", "xtd.core", "src", "xtd" });
    Console.WriteLine("Generation started");
    Console.Write("  * Generate Cultures...  ");
    Console.WriteLine(GenerateCultures(Path.Combine(new[] { xtdSourcesPath, "globalization", "culture_info_cultures.cpp" })) ? "[SUCCEED]" : "[FAILED ]");
    Console.Write("  * Generate DateTimeFormats...  ");
    Console.WriteLine(GenerateDateTimeFormats(Path.Combine(new[] { xtdSourcesPath, "globalization", "date_time_format_info_formats.cpp" })) ? "[SUCCEED]" : "[FAILED ]");
    Console.Write("  * Generate TimeZones... ");
    Console.WriteLine(GenerateTimeZones(Path.Combine(new[] { xtdSourcesPath, "time_zone_info_system_time_zones.cpp" })) ? "[SUCCEED]" : "[FAILED ]");
    Console.WriteLine("Generation ended");
    Environment.Exit(Environment.ExitCode);
  }

  static bool GenerateCultures(string file_path) {
    try {
      var sb = new StringBuilder();
      sb.AppendLine("// This code was generated by tools/GenerateCultureInfoCpp.");
      sb.AppendLine("//");
      sb.AppendLine("// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.");
      sb.AppendLine();
      sb.AppendLine("#include \"../../../include/xtd/globalization/culture_info.hpp\"");
      sb.AppendLine("#include \"../../../include/xtd/day_of_week.hpp\"");
      sb.AppendLine();
      sb.AppendLine("using namespace xtd;");
      sb.AppendLine("using namespace xtd::collections::generic;");
      sb.AppendLine("using namespace xtd::globalization;");
      sb.AppendLine();
      sb.AppendLine("dictionary<string, culture_info> culture_info::cultures_ = dictionary<string, culture_info> {");

      foreach (var cultureInfo in CultureInfo.GetCultures(CultureTypes.AllCultures).OrderBy(culture => culture.Name))
        sb.AppendLine(ToString(cultureInfo, Escape(cultureInfo.Name.ToLower())));
      sb.AppendLine("};");
      File.WriteAllText(file_path, sb.ToString(), Encoding.UTF8);
      return true;
    } catch (Exception e) {
      Trace.WriteLine("ERROR: " + e.Message);
      Environment.ExitCode = 2;
      return false;
    }
  }

  static bool GenerateDateTimeFormats(string file_path) {
    try {
      var sb = new StringBuilder();
      sb.AppendLine("// This code was generated by tools/GenerateCultureInfoCpp.");
      sb.AppendLine("//");
      sb.AppendLine("// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.");
      sb.AppendLine();
      sb.AppendLine("#include \"../../../include/xtd/globalization/date_time_format_info.hpp\"");
      sb.AppendLine("#include \"../../../include/xtd/day_of_week.hpp\"");
      sb.AppendLine();
      sb.AppendLine("using namespace xtd;");
      sb.AppendLine("using namespace xtd::collections::generic;");
      sb.AppendLine("using namespace xtd::globalization;");
      sb.AppendLine();
      sb.AppendLine("dictionary<string, date_time_format_info> date_time_format_info::formats_ = dictionary<string, date_time_format_info> {");

      foreach (var cultureInfo in CultureInfo.GetCultures(CultureTypes.AllCultures).OrderBy(culture => culture.Name))
        sb.AppendLine(ToString(cultureInfo.DateTimeFormat, Escape(cultureInfo.Name.ToLower())));
      sb.AppendLine("};");
      File.WriteAllText(file_path, sb.ToString(), Encoding.UTF8);
      return true;
    } catch (Exception e) {
      Trace.WriteLine("ERROR: " + e.Message);
      Environment.ExitCode = 2;
      return false;
    }
  }

  static bool GenerateTimeZones(string file_path) {
    Trace.WriteLine("ERROR: Not yet implemented.");
      Environment.ExitCode = 3;
    return false;
  }

  static string Escape(string text) => text.Replace("\\", "\\\\").Replace("\"", "\\\"");

  static bool IsUsingNls() {
    var property = typeof(CultureInfo).Assembly.GetType("System.Globalization.GlobalizationMode")?.GetProperty("UseNls", BindingFlags.Static | BindingFlags.NonPublic);
    return property != null && (bool)property.GetValue(null)!;
  }

  static string ToString(CultureInfo cultureInfo, string key) {
    return $"  key_value_pair<string, culture_info>(\"{key}\", {ToString(cultureInfo)}),";
  }

  static string ToString(CultureInfo cultureInfo) {
    var cultureType = ToString(cultureInfo.CultureTypes & CultureTypes.AllCultures);
    var displayName = Escape(cultureInfo.DisplayName);
    var englishName = Escape(cultureInfo.EnglishName);
    var keyboardLayoutId = cultureInfo.KeyboardLayoutId;
    var lcid = cultureInfo.LCID;
    var name = Escape(cultureInfo.Name);
    var nativeName = Escape(cultureInfo.NativeName);
    var parentName = Escape(cultureInfo.Parent.Name);
    var threeLetterISOLanguageName = Escape(cultureInfo.ThreeLetterISOLanguageName);
    var threeLetterWindowsLanguageName = Escape(cultureInfo.ThreeLetterWindowsLanguageName);
    var twoLetterISOLanguageName = Escape(cultureInfo.TwoLetterISOLanguageName);
    return $"culture_info({cultureType}, \"{displayName}\", \"{englishName}\", {keyboardLayoutId}, {lcid}, \"{name}\", \"{nativeName}\", \"{parentName}\", \"{threeLetterISOLanguageName}\", \"{threeLetterWindowsLanguageName}\", \"{twoLetterISOLanguageName}\")";
  }

  static string ToString(CultureTypes type) {
    var result = string.Empty;
    if (type.HasFlag(CultureTypes.NeutralCultures)) result = "globalization::culture_types::neutral_cultures";
    if (type.HasFlag(CultureTypes.SpecificCultures)) result += (string.IsNullOrEmpty(result) ? "" : "|") + "globalization::culture_types::specific_cultures";
    if (type.HasFlag(CultureTypes.InstalledWin32Cultures)) result += (string.IsNullOrEmpty(result) ? "" : "|") + "globalization::culture_types::installed_win32_cultures";
    if (string.IsNullOrEmpty(result)) result = "globalization::culture_types::none";
    return result;
  }
  
  static string ToString(DateTimeFormatInfo dateTimeFormat, string key) {
    return $"  key_value_pair<string, date_time_format_info>(\"{key}\", {ToString(dateTimeFormat)}),";
  }
  
  static string ToString(DateTimeFormatInfo dateTimeFormat) {
    var abbreviatedDayNames = ToString(dateTimeFormat.AbbreviatedDayNames);
    var abbreviatedMonthGenitiveNames = ToString(dateTimeFormat.AbbreviatedMonthGenitiveNames);
    var abbreviatedMonthNames = ToString(dateTimeFormat.AbbreviatedMonthNames);
    var amDesignator = Escape(dateTimeFormat.AMDesignator);
    var dateSeparator = Escape(dateTimeFormat.DateSeparator);
    var dayNames = ToString(dateTimeFormat.DayNames);
    var firstDayOfWeek = ToString(dateTimeFormat.FirstDayOfWeek);
    var fullDateTimePattern = Escape(dateTimeFormat.FullDateTimePattern);
    var longDatePattern = Escape(dateTimeFormat.LongDatePattern);
    var longTimePattern = Escape(dateTimeFormat.LongTimePattern);
    var monthDayPattern = Escape(dateTimeFormat.MonthDayPattern);
    var monthGenitiveNames = ToString(dateTimeFormat.MonthGenitiveNames);
    var monthNames = ToString(dateTimeFormat.MonthNames);
    var nativeCalendarName = Escape(dateTimeFormat.NativeCalendarName);
    var pmDesignator = Escape(dateTimeFormat.PMDesignator);
    var rfc1123Pattern = Escape(dateTimeFormat.RFC1123Pattern);
    var shortatePattern = Escape(dateTimeFormat.ShortDatePattern);
    var shortTimePattern = Escape(dateTimeFormat.ShortTimePattern);
    var shortestDayNames = ToString(dateTimeFormat.ShortestDayNames);
    var sortableDateTimePattern = Escape(dateTimeFormat.SortableDateTimePattern);
    var timeSeparator = Escape(dateTimeFormat.TimeSeparator);
    var universalSortableDateTimePattern = Escape(dateTimeFormat.UniversalSortableDateTimePattern);
    var yearMonthPattern = Escape(dateTimeFormat.YearMonthPattern);
    return $"date_time_format_info({abbreviatedDayNames}, {abbreviatedMonthGenitiveNames}, {abbreviatedMonthNames}, \"{amDesignator}\", \"{dateSeparator}\", {dayNames}, {firstDayOfWeek}, \"{fullDateTimePattern}\", \"{longDatePattern}\", \"{longTimePattern}\", \"{monthDayPattern}\", {monthGenitiveNames}, {monthNames}, \"{nativeCalendarName}\", \"{pmDesignator}\", \"{rfc1123Pattern}\", \"{shortatePattern}\", \"{shortTimePattern}\", {shortestDayNames}, \"{sortableDateTimePattern}\", \"{timeSeparator}\", \"{universalSortableDateTimePattern}\", \"{yearMonthPattern}\")";
  }

  static string ToString(DayOfWeek dayOfWeek) {
    return $"xtd::day_of_week::{dayOfWeek.ToString().ToLower()}";
  }
  
  static string ToString(string[] values) {
    var result = "array<string> {";
    foreach (var value in values)
      result += $"\"{Escape(value)}\", ";
    if (result.EndsWith(", ")) result = result.Substring(0, result.Length - 2);
    result += "}";
    return result;
  }
}
